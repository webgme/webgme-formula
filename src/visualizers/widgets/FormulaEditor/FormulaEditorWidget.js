/*globals define, WebGMEGlobal*/
/*jshint browser: true*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Fri May 13 2016 16:30:58 GMT-0500 (CDT).
 */

define([
    './FormulaCodeMirrorMode',
    'js/Loader/LoaderCircles',
    'js/DragDrop/DropTarget',
    'text!./FormulaEditor.html'
], function (CodeMirror, LoaderCircles, dropTarget, FormulaEditorHtml) {
    'use strict';

    var FormulaEditorWidget,
        WIDGET_CLASS = 'formula-editor';

    // TODO check if regular expression is correct and if it is fine here - no other users
    function getConstraintNamesFromText(txt) {
        var regExp = /\w+(?= *:-[\s\S]*\.)/g,
            result = txt.match(regExp);

        return result || [];
    }

    function getConstraintResultElem(name, result) {
        if (result === true) {
            return $('<li class="clist-elem clist-true"><i class="glyphicon glyphicon-ok"/>' + name + '</li>');
        } else if (result === false) {
            return $('<li class="clist-elem clist-false"><i class="glyphicon glyphicon-remove"/>' + name + '</li>');
        } else {
            return $('<li class="clist-elem">' + name + '</li>');
        }
    }

    FormulaEditorWidget = function (logger, container) {
        this._logger = logger.fork('Widget');

        this._el = container;
        this._codeMirrorEl = null;
        this._listEl = null;
        this._initialize();

        this._logger.debug('ctor finished');
    };

    FormulaEditorWidget.prototype._initialize = function () {
        var width = this._el.width(),
            height = this._el.height(),
            self = this;

        // set widget class
        this._el.addClass(WIDGET_CLASS);

        $(this._el).css({
            'padding': '0'
        });

        this._el.append(FormulaEditorHtml);

        this._saveConstraintsBtn = this._el.find('#constraintBtn').first();

        this._saveConstraintsBtn.on('click', function (/*event*/) {
            self._previousCodeState = self._codemirror.getValue();
            self.onSaveConstraints(self._previousCodeState);
            self._saveConstraintsBtn.attr('disabled', true);
            self.setResults({}); // constraints probably changed so we clear the results
        });

        // adding domain and its own codemirror
        this._domainBtn = this._el.find('#domainBtn').first();
        this._domainMirrorEl = this._el.find('#domainarea').first();
        this._domainMirrorEl.focus();
        this._domainmirror = CodeMirror.fromTextArea(this._domainMirrorEl.get(0), {
            lineNumbers: true,
            readOnly: true,
            matchBrackets: true,
            mode: {
                name: 'formula',
                globalVars: true
            },
            dragDrop: false
        });
        this._domainVisible = false;
        this._domainBtn.on('click', function (/*event*/) {
            if (self._domainVisible) {
                self._domainVisible = false;
                $(self._domainmirror.getWrapperElement()).hide();
            } else {
                self._domainVisible = true;
                $(self._domainmirror.getWrapperElement()).show();
            }
            self._resizeWidget(self._domainVisible, self._el.height());
        });
        $(self._domainmirror.getWrapperElement()).hide(); //by default we hide it

        this._codeMirrorEl = this._el.find('#codearea').first();
        this._codeMirrorEl.focus();
        this._codemirror = CodeMirror.fromTextArea(this._codeMirrorEl.get(0), {
            lineNumbers: true,
            theme: 'monokai',
            matchBrackets: true,
            mode: {
                name: 'formula',
                globalVars: true
            },
            dragDrop: false
        });

        this._codemirror.on('change', function () {
            // If the content is changed from the last saved one we allow the save button.
            // Otherwise it will be disabled
            if (self._autoSaveTimer) {
                clearTimeout(self._autoSaveTimer);
            }
            self._autoSaveTimer = setTimeout(function () {
                self._autoSave();
                self._autoSaveTimer = null;
            }, self._autoSaveInterval);
        });

        this._codemirror.on('drop', function (cm, event) {
            // console.log('dropping', event);
        });

        this._codemirror.on('cursorActivity', function (cm) {
            // console.log('update', cm);
        });

        this._codemirror.on('focus', function (cm) {
            // console.log('focused', cm.getValue());
        });

        this._autoSaveInterval = 2000; //1s autoSave - if change happened
        this._autoSaveTimer = null;
        this._previousCodeState = null;

        this._constraintList = this._el.find('#constraintlist').first();
        this._checkContraintsBtn = this._el.find('#checkBtn').first();

        this._checkContraintsBtn.on('click', function (event) {
            self.onCheckConstraints(getConstraintNamesFromText(self._codemirror.getValue()));
        });
        self._saveConstraintsBtn.attr('disabled', true);

        this._allOk = this._el.find('#allResultOk').first();
        this._allOk.hide();
        this._allOk.attr('disabled', true);

        //make it dropable
        dropTarget.makeDroppable($(this._el).find('.CodeMirror'), {
            over: function (event, dragInfo) {
                // console.log('over: ', event, dragInfo);
            },
            out: function (event, dragInfo) {
                // console.log('out: ', event, dragInfo);
            },
            drop: function (event, dragInfo) {
                console.log('drop: ', event, dragInfo);
                var cursor = self._codemirror.getCursor(),
                    metaName,
                    nodeName,
                    gmeNode;
                if (dragInfo && dragInfo.DRAG_ITEMS && dragInfo.DRAG_ITEMS.length === 1) {
                    // we can only insert single types...
                    gmeNode = WebGMEGlobal.Client.getNode(dragInfo.DRAG_ITEMS[0]);
                    if (gmeNode) {
                        metaName = WebGMEGlobal.Client.getNode(gmeNode.getMetaTypeId()).getFullyQualifiedName();
                        nodeName = 'node_' + gmeNode.getFullyQualifiedName();
                        metaName = nodeName +
                            ' is ' + metaName + ', ' + nodeName + '.id = "' + dragInfo.DRAG_ITEMS[0] + '"';
                        self._codemirror.replaceRange(metaName, cursor);
                    }
                }
            },
            activate: function (event, dragInfo) {
                // console.log('activate: ', event, dragInfo);
            },
            deactivate: function (event, dragInfo) {
                // console.log('deactivate: ', event, dragInfo);
            }
        });

        this._codemirror.refresh();

        this._loader = new LoaderCircles({containerElement: this._el});
    };

    FormulaEditorWidget.prototype.onWidgetContainerResize = function (width, height) {
        this._logger.debug('Widget is resizing...');
        this._resizeWidget(this._domainVisible, height);
    };

    FormulaEditorWidget.prototype._resizeWidget = function (isSplit, height) {
        if (isSplit) {
            $(this._el).find('.CodeMirror').css({
                height: height - 25 > 200 ? (height - 25) / 2 : 100
            });
            this._domainmirror.focus();
            this._domainmirror.refresh();
            this._codemirror.focus();
            this._codemirror.refresh();
        } else {
            $(this._el).find('.CodeMirror').css({
                height: height - 25 > 200 ? height - 25 : 200
            });
            this._codemirror.focus();
            this._codemirror.refresh();
        }
    };

    // Auto-save functions

    FormulaEditorWidget.prototype._autoSave = function () {
        if (this._previousCodeState !== this._codemirror.getValue()) {
            this._previousCodeState = this._codemirror.getValue();
            this.onSaveConstraints(this._previousCodeState);
            this._saveConstraintsBtn.attr('disabled', true);
            this.setResults({}); //something changed, we clear results
        }
    };

    FormulaEditorWidget.prototype._startAutoSave = function () {
        // no need for start as we only autosave if user stops editing for autosave-time
    };
    FormulaEditorWidget.prototype._stopAutoSave = function () {
        if (this._autoSaveTimer) {
            clearTimeout(this._autoSaveTimer);
            this._autoSaveTimer = null;
        }
    };

    FormulaEditorWidget.prototype.getConstraints = function () {
        return this._codemirror.getValue();
    };

    FormulaEditorWidget.prototype.setDomain = function (text) {
        var cursor = this._domainmirror.getCursor();
        this._domainmirror.setValue(text);
        this._domainmirror.refresh();
        this._domainmirror.setCursor(cursor);
    };

    FormulaEditorWidget.prototype.setConstraints = function (text) {
        // setting code from outside so the auto-save should not be triggered
        var cursor;
        this._previousCodeState = text;
        if (text !== this._codemirror.getValue()) {
            cursor = this._codemirror.getCursor();
            this._codemirror.setValue(text);
            this._codemirror.refresh();
            this._codemirror.setCursor(cursor);
            this.setResults({}); //something is changed so we clear the results, just to be on the safe side
        }
    };

    FormulaEditorWidget.prototype.setResults = function (resultObject) {
        var constraints = getConstraintNamesFromText(this._codemirror.getValue()).sort(),
            i,
            allOk = true;
        this._loader.stop();
        this._constraintList.empty();
        for (i = 0; i < constraints.length; i += 1) {
            if (typeof resultObject[constraints[i]] === 'boolean') {
                if (resultObject[constraints[i]]) {
                    this._constraintList.append(getConstraintResultElem(constraints[i], true));
                } else {
                    allOk = false;
                    this._constraintList.append(getConstraintResultElem(constraints[i], false));
                }
            } else {
                allOk = false;
                this._constraintList.append(getConstraintResultElem(constraints[i]));
            }
        }
        if (allOk) {
            this._allOk.show();
        } else {
            this._allOk.hide();
        }
    };

    FormulaEditorWidget.prototype.waitForResults = function () {
        this.setResults({});
        this._loader.start();
    };
    /* * * * * * * * Visualizer event handlers * * * * * * * */

    FormulaEditorWidget.prototype.onCheckConstraints = function () {
        this._logger.warn('The "onCheckConstraints" function is not overwritten');
    };

    FormulaEditorWidget.prototype.onSaveConstraints = function () {
        this._logger.warn('The "onSaveConstraints" function is not overwritten');
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    FormulaEditorWidget.prototype.destroy = function () {
        this._stopAutoSave();
    };

    FormulaEditorWidget.prototype.onActivate = function () {
        this._logger.debug('FormulaEditorWidget has been activated');
        this._startAutoSave();
    };

    FormulaEditorWidget.prototype.onDeactivate = function () {
        this._logger.debug('FormulaEditorWidget has been deactivated');
        this._stopAutoSave();
    };

    return FormulaEditorWidget;
});
